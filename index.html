<!-- ===== SlideBar Pro — vertical slide + bend + extra FX + loop + rec-all ===== -->
<script>
(() => {
  if (document.getElementById('sb-host')) return;

  const host = document.createElement('div');
  host.id = 'sb-host';
  host.style.all = 'initial';
  host.style.position = 'fixed';
  host.style.zIndex = '2147483647';
  document.body.appendChild(host);
  const root = host.attachShadow({mode:'open'});

  root.innerHTML = `
    <style>
      :root{ --glow:#7bffb3; --fg:#eafff4; --muted:#9fd0c0; --line:#153425; --bg:#01150f; }
      /* Launcher (stacked above Guitar & Slide) */
      .pill{
        position:fixed; right:14px; bottom:126px; /* SLIDEBAR above GUITAR(70px) & SLIDE(14px) */
        padding:12px 20px; border-radius:999px;
        background:var(--bg); border:1px solid var(--line);
        color:var(--fg); font-weight:900; font-size:16px; letter-spacing:.8px; cursor:pointer;
        box-shadow:0 0 14px var(--glow), 0 0 32px rgba(123,255,179,.7);
        user-select:none; -webkit-user-select:none; -webkit-touch-callout:none; touch-action:manipulation;
      }
      .pill:active{ transform:scale(.96) }

      .panel{
        position:fixed; inset:0; display:none; background:rgba(0,0,0,.92); backdrop-filter:blur(10px);
        color:var(--fg); user-select:none; -webkit-user-select:none; -webkit-touch-callout:none;
      }
      .panel.open{ display:block }
      .close{
        position:absolute; top:14px; right:16px; background:var(--glow); color:#003025;
        border:none; border-radius:999px; padding:.45rem .9rem; font-weight:900; cursor:pointer;
        box-shadow:0 0 16px var(--glow);
      }

      .wrap{ max-width:1100px; margin:60px auto 20px; padding:0 14px; display:flex; flex-direction:column; gap:12px }
      .card{
        background:rgba(10,14,12,.92); border:1px solid var(--line); border-radius:12px; padding:12px;
        box-shadow:0 12px 44px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
      }
      .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
      .col{ display:flex; flex-direction:column; gap:6px; min-width:200px }
      .lbl{ font:12px/1 system-ui; color:var(--muted) }
      .btn{
        background:var(--glow); color:#00261e; font-weight:800; border:none; cursor:pointer;
        padding:.55rem 1rem; border-radius:10px; font-size:15px; box-shadow:0 0 12px var(--glow),0 0 24px var(--glow);
      }
      .select{ background:#071a14; color:var(--fg); border:1px solid var(--line); border-radius:10px; padding:.55rem .8rem; }
      .slider{ -webkit-appearance:none; appearance:none; height:10px; border-radius:10px; background:#0f1a14; outline:none; box-shadow:inset 0 0 0 1px #183225, 0 0 10px rgba(123,255,179,.25) }
      .slider::-webkit-slider-thumb{ -webkit-appearance:none; width:22px; height:22px; border-radius:50%; background:var(--glow); box-shadow:0 0 14px var(--glow) }
      .slider::-moz-range-thumb{ width:22px; height:22px; border-radius:50%; background:var(--glow); box-shadow:0 0 14px var(--glow) }

      /* Slide bar */
      #slidebar{
        position:relative; width:90px; height:360px; margin:10px; border:1px solid #183225; border-radius:16px;
        background:linear-gradient(180deg,#0b1713,#08130f);
        touch-action:none;
      }
      #marker{ position:absolute; left:10%; right:10%; height:6px; border-radius:6px; background:var(--glow); box-shadow:0 0 14px var(--glow); pointer-events:none; }
      .scale{
        flex:1; display:grid; grid-template-columns:repeat(8,minmax(60px,1fr)); gap:8px; align-items:end;
      }
      .note{
        background:#0e1b16; border:1px solid #163729; color:#bfffe3; border-radius:10px; padding:.4rem .6rem; text-align:center;
        box-shadow:inset 0 0 0 1px #0f2c20;
      }

      .vu{ width:14px; height:66px; border:1px solid #183225; border-radius:6px; background:#0c1117; overflow:hidden }
      .vu .bar{ width:100%; height:0; background:linear-gradient(#c6ffd7,#7bffb3) }
      .prog{ position:relative; height:12px; background:#0c1117; border:1px solid #183225; border-radius:999px; overflow:hidden; min-width:220px }
      .prog > span{ position:absolute; top:0; left:0; bottom:0; width:0%; background:#7bffb3; box-shadow:0 0 10px #7bffb3 }
    </style>

    <button id="pill" class="pill">SLIDEBAR</button>

    <div id="panel" class="panel">
      <button id="close" class="close">X</button>
      <div class="wrap">

        <!-- Slide + scale notes -->
        <section class="card">
          <div class="row">
            <div class="col">
              <span class="lbl">Slide Bar — touch to play · drag up = bend (up to +12 semitones)</span>
              <div id="slidebar"><div id="marker" style="top:50%"></div></div>
            </div>
            <div class="col" style="min-width:420px">
              <span class="lbl">Scale notes (tap: sets target note / base)</span>
              <div class="scale" id="scaleRow"></div>
            </div>
          </div>
        </section>

        <!-- Core & Pitch -->
        <section class="card">
          <div class="row">
            <div class="col"><span class="lbl">Master Vol</span><input id="masterVol" class="slider" type="range" min="0" max="1.4" step="0.01" value="1.0"></div>
            <div class="col"><span class="lbl">Pad Level</span><input id="padLevel" class="slider" type="range" min="0.5" max="3" step="0.01" value="1.3"></div>
            <div class="col"><span class="lbl">Octave</span><input id="octave" class="slider" type="range" min="-2" max="2" step="1" value="0"></div>
            <div class="col"><span class="lbl">Base (Hz)</span><input id="baseHz" class="slider" type="range" min="40" max="220" step="1" value="110"></div>
            <div class="col"><span class="lbl">Range (Oct)</span><input id="rangeOct" class="slider" type="range" min="1" max="5" step="0.1" value="3"></div>
            <div class="col"><span class="lbl">Glide (ms)</span><input id="glide" class="slider" type="range" min="0" max="200" step="1" value="14"></div>
          </div>
        </section>

        <!-- Extra FX -->
        <section class="card">
          <div class="row">
            <div class="col"><span class="lbl">Low-Pass</span><input id="fxLP" class="slider" type="range" min="300" max="10000" step="1" value="4200"></div>
            <div class="col"><span class="lbl">Drive</span><input id="fxDrive" class="slider" type="range" min="0" max="1" step="0.01" value="0.35"></div>
            <div class="col"><span class="lbl">Chorus Mix</span><input id="fxChorus" class="slider" type="range" min="0" max="1" step="0.01" value="0.25"></div>
            <div class="col"><span class="lbl">Phaser Rate</span><input id="fxPhRate" class="slider" type="range" min="0" max="4" step="0.01" value="0.5"></div>
            <div class="col"><span class="lbl">Delay Mix</span><input id="fxDelay" class="slider" type="range" min="0" max="0.8" step="0.01" value="0.26"></div>
            <div class="col"><span class="lbl">Reverb Mix</span><input id="fxVerb" class="slider" type="range" min="0" max="0.8" step="0.01" value="0.22"></div>
            <div class="col"><span class="lbl">Limiter Drive</span><input id="limDrive" class="slider" type="range" min="0" max="24" step="0.1" value="10"></div>
            <div class="col"><span class="lbl">Output Boost</span><input id="outBoost" class="slider" type="range" min="0.5" max="3" step="0.01" value="1.3"></div>
            <div class="col"><span class="lbl">Soft Clip</span><input id="clipAmt" class="slider" type="range" min="0" max="1" step="0.01" value="0.22"></div>
          </div>
        </section>

        <!-- Loop + Rec All -->
        <section class="card">
          <div class="row">
            <button class="btn" id="loopRec">● Loop Rec</button>
            <button class="btn" id="loopStopRec" disabled>■ Stop</button>
            <button class="btn" id="loopPlay" disabled>▶ Play</button>
            <button class="btn" id="loopStop" disabled>⏹ Stop</button>
            <button class="btn" id="loopClear" disabled>✖ Clear</button>
            <div class="col"><span class="lbl">Loop Vol</span><input id="loopVol" class="slider" type="range" min="0" max="2.5" step="0.01" value="1.1"></div>
            <div class="col"><span class="lbl">Loop Speed</span><input id="loopSpd" class="slider" type="range" min="0.5" max="1.5" step="0.01" value="1"></div>
            <button class="btn" id="recAllStart">ALL ●</button>
            <button class="btn" id="recAllStop" disabled>ALL ⏹</button>
            <div class="row" style="gap:8px">
              <div class="vu"><div class="bar" id="vuL"></div></div>
              <div class="vu"><div class="bar" id="vuR"></div></div>
            </div>
            <div class="col"><span class="lbl">Progress</span><div class="prog"><span id="prog"></span></div></div>
          </div>
        </section>

      </div>
    </div>
  `;

  const $ = s=>root.querySelector(s);
  const pill=$('#pill'), panel=$('#panel'), closeBtn=$('#close');
  pill.onclick=()=> panel.classList.add('open');
  closeBtn.onclick=()=> panel.classList.remove('open');

  /* ===== Audio Core ===== */
  const AC = new (window.AudioContext||window.webkitAudioContext)();
  const master = AC.createGain(); master.gain.value = +$('#masterVol').value;

  const comp = AC.createDynamicsCompressor();
  function setLimiterDrive(db){ comp.threshold.value = -12 - db*0.6; comp.knee.value=10; comp.ratio.value=12; comp.attack.value=.003; comp.release.value=.09; }
  setLimiterDrive(+$('#limDrive').value);

  const clipper = AC.createWaveShaper();
  function mkClip(a){ const n=2048,c=new Float32Array(n),k=a*20+1e-3; for(let i=0;i<n;i++){ const x=i/n*2-1; c[i]=Math.tanh(x*k); } return c; }
  clipper.curve = mkClip(+$('#clipAmt').value);

  const outBoost = AC.createGain(); outBoost.gain.value = +$('#outBoost').value;

  master.connect(comp).connect(clipper).connect(outBoost).connect(AC.destination);

  // FX: LP -> Drive -> (Chorus->Phaser)-> Delay -> Verb -> Master
  const lp = AC.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = +$('#fxLP').value;
  const drive = AC.createWaveShaper(); function curve(a){ const n=2048,c=new Float32Array(n); for(let i=0;i<n;i++){ const x=i/n*2-1; c[i]=(1+a)*x/(1+a*Math.abs(x)); } return c; }
  drive.curve = curve(+$('#fxDrive').value);

  // Chorus (short delay mod)
  const chorusDelay = AC.createDelay(0.03); chorusDelay.delayTime.value = 0.015;
  const chorusMix   = AC.createGain(); chorusMix.gain.value = +$('#fxChorus').value;
  const chorusLFO   = AC.createOscillator(); chorusLFO.type='sine'; chorusLFO.frequency.value=0.25;
  const chorusDepth = AC.createGain(); chorusDepth.gain.value = 0.006; // 6ms depth
  chorusLFO.connect(chorusDepth).connect(chorusDelay.delayTime); chorusLFO.start();

  // Phaser (allpass sweep)
  function makeAllpass(freq){ const ap = AC.createBiquadFilter(); ap.type='allpass'; ap.frequency.value=freq; return ap; }
  const ap1=makeAllpass(400), ap2=makeAllpass(800), ap3=makeAllpass(1600), ap4=makeAllpass(3200);
  ap1.connect(ap2).connect(ap3).connect(ap4);
  const phaserRate = $('#fxPhRate'); const phLFO = AC.createOscillator(); phLFO.type='sine'; phLFO.frequency.value=+phaserRate.value||0.5;
  const phGain1=AC.createGain(), phGain2=AC.createGain(), phGain3=AC.createGain(), phGain4=AC.createGain();
  phGain1.gain.value=300; phGain2.gain.value=600; phGain3.gain.value=1200; phGain4.gain.value=1800;
  phLFO.connect(phGain1); phLFO.connect(phGain2); phLFO.connect(phGain3); phLFO.connect(phGain4);
  phGain1.connect(ap1.frequency); phGain2.connect(ap2.frequency); phGain3.connect(ap3.frequency); phGain4.connect(ap4.frequency);
  phLFO.start();

  const delay = AC.createDelay(1.0); delay.delayTime.value=.28;
  const dMix  = AC.createGain(); dMix.gain.value=+$('#fxDelay').value;
  const dFB   = AC.createGain(); dFB.gain.value=.32; delay.connect(dFB).connect(delay);

  const verb  = AC.createConvolver(); (()=>{
    const rate=AC.sampleRate,len=rate*2|0,buf=AC.createBuffer(2,len,rate);
    for(let ch=0; ch<2; ch++){ const data=buf.getChannelData(ch); for(let i=0;i<len;i++){ data[i]=(Math.random()*2-1)*Math.pow(1-i/len,2.4); } }
    verb.buffer = buf;
  })();
  const vMix  = AC.createGain(); vMix.gain.value = +$('#fxVerb').value;

  // Wire chain: synth -> lp -> drive -> chorus -> phaser -> (dry to master) + (delay/verb sends)
  const fxBus = AC.createGain(); // synth connects here
  fxBus.connect(lp).connect(drive);
  drive.connect(chorusDelay).connect(ap1);  // wet into phaser
  drive.connect(ap1);                       // also feed phaser from dry drive (for more swirl)
  ap4.connect(master);
  ap4.connect(delay).connect(dMix).connect(master);
  ap4.connect(verb).connect(vMix).connect(master);
  drive.connect(chorusMix).connect(master); // small direct chorus mix

  // UI hooks
  $('#masterVol').oninput = e=> master.gain.value = +e.target.value;
  $('#fxLP').oninput      = e=> lp.frequency.value = +e.target.value;
  $('#fxDrive').oninput   = e=> drive.curve = curve(+e.target.value);
  $('#fxChorus').oninput  = e=> chorusMix.gain.value = +e.target.value;
  phaserRate.oninput      = e=> phLFO.frequency.value = +e.target.value || 0;
  $('#fxDelay').oninput   = e=> dMix.gain.value = +e.target.value;
  $('#fxVerb').oninput    = e=> vMix.gain.value = +e.target.value;
  $('#limDrive').oninput  = e=> setLimiterDrive(+e.target.value);
  $('#clipAmt').oninput   = e=> clipper.curve = mkClip(+e.target.value);
  $('#outBoost').oninput  = e=> outBoost.gain.value = +e.target.value;

  /* ===== Synth (vertical slide) ===== */
  let osc=null, gain=null; let PAD_LVL=+$('#padLevel').value;
  $('#padLevel').oninput = e=> PAD_LVL = +e.target.value;

  function startOsc(freq){
    if(osc) return;
    osc = AC.createOscillator(); osc.type='sawtooth';
    gain = AC.createGain(); gain.gain.value=0;
    osc.connect(gain).connect(fxBus);
    osc.frequency.value = freq; osc.start();
    gain.gain.setTargetAtTime(PAD_LVL, AC.currentTime, 0.01);
  }
  function stopOsc(){
    if(!osc) return;
    gain.gain.setTargetAtTime(0, AC.currentTime, 0.06);
    try{ osc.stop(AC.currentTime+0.08); }catch{}
    setTimeout(()=>{ try{ osc.disconnect(); gain.disconnect(); }catch{}; osc=null; gain=null; }, 120);
  }

  function freqFromY(y){
    const bar = $('#slidebar').getBoundingClientRect();
    const frac = 1 - Math.min(1, Math.max(0, (y - bar.top)/bar.height)); // 0..1
    const base=+$('#baseHz').value, range=+$('#rangeOct').value, oct=+$('#octave').value;
    return base * Math.pow(2, oct + frac*range);
  }
  function setMarker(y){
    const bar = $('#slidebar').getBoundingClientRect();
    const clamped = Math.min(bar.bottom, Math.max(bar.top, y));
    $('#marker').style.top = (clamped - bar.top) + 'px';
  }

  // Bend amount (0..+12 semitones based on distance above touch origin)
  let touchBaseF=0, startY=0;
  function bendFromDelta(dy){ // dy negative when dragging up
    const semis = Math.min(12, Math.max(0, (-dy) / 6)); // 6px per semitone (~+12 max)
    return Math.pow(2, semis/12);
  }

  // Scale notes (tap to set base target quickly)
  const scaleHz = (root=>{
    // A minor pentatonic over one octave (8 notes)
    const ratios = [1, 6/5, 4/3, 3/2, 2, 12/5, 8/3, 3]; // rough musical spread
    return function(base){ return ratios.map(r=> base*r); };
  })();
  function buildScale(){
    const row = $('#scaleRow'); row.innerHTML='';
    const base = +$('#baseHz').value;
    scaleHz(base).forEach((hz,i)=>{
      const d=document.createElement('div'); d.className='note';
      d.textContent = (['1','♭3','4','5','8','♭10','♭13','15'][i]||'');
      d.title = hz.toFixed(1)+' Hz';
      d.onclick = ()=>{ touchBaseF = hz; if(AC.state!=='running') AC.resume(); startOsc(hz); setTimeout(()=>stopOsc(), 150); };
      row.appendChild(d);
    });
  }
  buildScale();
  $('#baseHz').oninput = ()=> buildScale();

  // Interactions
  let down=false, id=null;
  const slide = $('#slidebar');
  slide.addEventListener('pointerdown', e=>{
    e.preventDefault();
    if(AC.state!=='running') AC.resume();
    down=true; id=e.pointerId; slide.setPointerCapture(id);
    startY = e.clientY; touchBaseF = freqFromY(e.clientY);
    startOsc(touchBaseF); setMarker(e.clientY);
  }, {passive:false});
  slide.addEventListener('pointermove', e=>{
    if(!down || e.pointerId!==id) return;
    e.preventDefault();
    const target = touchBaseF * bendFromDelta(e.clientY - startY);
    const t = Math.max(0.001, (+$('#glide').value)/1000);
    try{ osc.frequency.setTargetAtTime(target, AC.currentTime, t); }catch{ if(osc) osc.frequency.value=target; }
    setMarker(e.clientY);
  }, {passive:false});
  slide.addEventListener('pointerup', e=>{ if(e.pointerId!==id) return; e.preventDefault(); down=false; id=null; stopOsc(); }, {passive:false});
  slide.addEventListener('pointercancel', ()=>{ down=false; id=null; stopOsc(); }, {passive:false});
  slide.addEventListener('contextmenu', e=> e.preventDefault(), {passive:false});

  /* ===== Looper + VU + Record-All ===== */
  const L = { rec:$('#loopRec'), stopR:$('#loopStopRec'), play:$('#loopPlay'), stop:$('#loopStop'), clear:$('#loopClear'), vol:$('#loopVol'), spd:$('#loopSpd'), vuL:$('#vuL'), vuR:$('#vuR'), prog:$('#prog') };
  const tap = AC.createGain(); outBoost.connect(tap); // record post-boost
  let recNode=null, recL=[], recR=[], loopBuf=null, loopSrc=null, loopGain=null, ana=null, raf=null, playStart=0;

  function setLoopState(s){ L.rec.disabled=(s==='rec'||s==='playing'); L.stopR.disabled=(s!=='rec'); L.play.disabled=!loopBuf; L.stop.disabled=(s!=='playing'); L.clear.disabled=!loopBuf; }

  function startRec(){
    recL=[]; recR=[];
    recNode = AC.createScriptProcessor(2048,2,2);
    recNode.onaudioprocess = e=>{
      const Lb=e.inputBuffer.getChannelData(0), Rb=e.inputBuffer.numberOfChannels>1?e.inputBuffer.getChannelData(1):Lb;
      recL.push(new Float32Array(Lb)); recR.push(new Float32Array(Rb));
    };
    tap.connect(recNode); recNode.connect(AC.destination);
    setLoopState('rec');
  }
  function stopRec(){
    if(!recNode) return;
    try{ tap.disconnect(recNode); }catch{} try{ recNode.disconnect(); }catch{};
    recNode.onaudioprocess=null; recNode=null;
    const len=recL.reduce((n,a)=>n+a.length,0); if(!len){ setLoopState('idle'); return; }
    loopBuf = AC.createBuffer(2,len,AC.sampleRate);
    let o=0; const Lch=loopBuf.getChannelData(0); for(const a of recL){ Lch.set(a,o); o+=a.length; }
    o=0; const Rch=loopBuf.getChannelData(1); for(const a of recR){ Rch.set(a,o); o+=a.length; }
    loopGain = loopGain || AC.createGain(); loopGain.gain.value = +L.vol.value;
    setLoopState('ready');
  }
  function playLoop(){
    if(!loopBuf) return; stopLoop();
    loopSrc = AC.createBufferSource();
    loopSrc.buffer=loopBuf; loopSrc.loop=true; loopSrc.playbackRate.value=+L.spd.value;
    if(!ana){ ana=AC.createAnalyser(); ana.fftSize=1024; }
    loopSrc.connect(loopGain).connect(master).connect(ana);
    loopSrc.start(); playStart=AC.currentTime; setLoopState('playing'); meters();
  }
  function stopLoop(){ if(loopSrc){ try{loopSrc.stop()}catch{}; try{loopSrc.disconnect()}catch{}; loopSrc=null; } if(raf){ cancelAnimationFrame(raf); raf=null; } L.prog.style.width='0%'; }
  function clearLoop(){ stopLoop(); loopBuf=null; if(loopGain) try{ loopGain.disconnect(); }catch{}; setLoopState('idle'); }

  L.rec.onclick = ()=>{ if(AC.state!=='running') AC.resume(); startRec(); };
  L.stopR.onclick = ()=> stopRec();
  L.play.onclick = ()=> playLoop();
  L.stop.onclick = ()=>{ stopLoop(); setLoopState('ready'); };
  L.clear.onclick = ()=> clearLoop();
  L.vol.oninput = ()=>{ if(loopGain) loopGain.gain.value = +L.vol.value; };
  L.spd.oninput = ()=>{ if(loopSrc) loopSrc.playbackRate.value = +L.spd.value; };

  function meters(){
    const data = new Uint8Array((ana||AC.createAnalyser()).frequencyBinCount);
    const tick = ()=>{
      if(!ana){ raf && cancelAnimationFrame(raf); return; }
      ana.getByteTimeDomainData(data);
      let pk=0; for(let i=0;i<data.length;i++){ const v=(data[i]-128)/128; pk=Math.max(pk,Math.abs(v)); }
      const h=Math.min(100,Math.floor(pk*160));
      L.vuL.style.height=h+'%'; L.vuR.style.height=h+'%';
      if(loopSrc && loopBuf){
        const dur = loopBuf.duration / (+L.spd.value||1);
        const t = (AC.currentTime - playStart) % dur;
        L.prog.style.width = (t/dur*100).toFixed(1)+'%';
      }
      raf = requestAnimationFrame(tick);
    };
    raf = requestAnimationFrame(tick);
  }
  setLoopState('idle');

  /* ===== Record All ===== */
  const recAllStart=$('#recAllStart'), recAllStop=$('#recAllStop');
  const recBus = AC.createMediaStreamDestination(); outBoost.connect(recBus);
  let recAll=null, chunks=[];
  recAllStart.onclick = ()=>{
    chunks=[];
    try{ recAll=new MediaRecorder(recBus.stream,{mimeType:'audio/webm;codecs=opus', audioBitsPerSecond:256000}); }
    catch{ try{ recAll=new MediaRecorder(recBus.stream); } catch(e){ alert('Recording not supported.'); return; } }
    recAll.ondataavailable = e=>{ if(e.data?.size) chunks.push(e.data); };
    recAll.onstop = ()=>{
      if(!chunks.length) return;
      const blob = new Blob(chunks, {type: recAll.mimeType || 'audio/webm'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='SlideBar_mix.webm'; a.click();
    };
    recAll.start(); recAllStart.disabled=true; recAllStop.disabled=false; if(AC.state!=='running') AC.resume();
  };
  recAllStop.onclick = ()=>{ try{ recAll?.stop(); }catch{}; recAllStart.disabled=false; recAllStop.disabled=true; };

  // Unlock audio on first interaction
  root.addEventListener('pointerdown', ()=>{ if(AC.state!=='running') AC.resume(); }, {once:true, passive:true});
})();
</script><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>PsyForge Kaleidoscope — Touch Safe + Working Record</title>
<style>
  :root{
    --fg:#eafff4; --muted:#9fd0c0; --line:#0f1a18;
    --pill:#07120e; --glow:#35ff9a; --glow2:#7bffc8;
    --rad:12px; --gap:8px;
    --sideW: 260px; --edgeH: 84px;
    --pad: max(10px, env(safe-area-inset-left,0px));
    --padR:max(10px, env(safe-area-inset-right,0px));
    --padT:max(10px, env(safe-area-inset-top,0px));
    --padB:max(10px, env(safe-area-inset-bottom,0px));
  }

  /* Page hard-lock (no scroll/zoom fighting your gestures) */
  html,body{
    margin:0; height:100%; width:100%;
    position:fixed; inset:0;
    overflow:hidden; overscroll-behavior:none; touch-action:none;
    background:#000; color:var(--fg);
    font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;
  }

  /* Center canvas */
  #stage{
    position:fixed; inset:0; z-index:0;
    width:100vw; height:100vh; display:block; background:#000; cursor:grab;
    touch-action:none;
  }

  /* Edge micro-docks */
  .pill{
    background:var(--pill); color:var(--fg); border:1px solid var(--line);
    border-radius:999px; padding:10px; font-size:18px; cursor:pointer;
    box-shadow:0 0 10px var(--glow), 0 0 20px var(--glow2);
    touch-action:manipulation;
  }
  .mini{
    background:linear-gradient(180deg,#081411,#0a1714);
    border:1px solid var(--line); border-radius:var(--rad);
    box-shadow:0 0 0 1px #0a1714, 0 0 18px rgba(53,255,154,.18);
    padding:10px; color:var(--fg); font-size:13px;
  }
  label{display:grid; gap:4px; font-size:12px; color:var(--muted)}
  input[type=range], input[type=file], button{ touch-action:manipulation; }
  input[type=range]{width:140px}

  /* TOP */
  .dockTop{position:fixed; z-index:10; left:50%; transform:translateX(-50%); top:var(--padT)}
  .topPanel{position:absolute; left:50%; transform:translate(-50%,8px); top:42px; width:min(96vw,560px); height:var(--edgeH); display:none}
  .dockTop.open .topPanel{display:block}

  /* BOTTOM */
  .dockBottom{position:fixed; z-index:10; left:50%; transform:translateX(-50%); bottom:var(--padB)}
  .botPanel{position:absolute; left:50%; transform:translate(-50%,-8px); bottom:42px; width:min(96vw,620px); height:var(--edgeH); display:none}
  .dockBottom.open .botPanel{display:block}

  /* LEFT */
  .dockLeft{position:fixed; z-index:10; left:var(--pad); top:50%; transform:translateY(-50%)}
  .leftPanel{position:absolute; left:calc(var(--pad) + 42px); top:50%; transform:translateY(-50%); width:var(--sideW); display:none}
  .dockLeft.open .leftPanel{display:block}

  /* RIGHT */
  .dockRight{position:fixed; z-index:10; right:var(--padR); top:50%; transform:translateY(-50%)}
  .rightPanel{position:absolute; right:calc(var(--padR) + 42px); top:50%; transform:translateY(-50%); width:var(--sideW); display:none}
  .dockRight.open .rightPanel{display:block}

  /* tiny Re button if you want it on this page too */
  .re{
    position:fixed; bottom:6px; left:6px; z-index:20;
    font-size:9px; padding:2px 6px; opacity:.55;
    background:rgba(0,0,0,.55); color:#eafff4;
    border:1px solid var(--glow); border-radius:6px; cursor:pointer;
    touch-action:manipulation;
  }
  .re:hover{opacity:1; box-shadow:0 0 6px var(--glow)}
</style>
</head>
<body>

<canvas id="stage"></canvas>

<!-- TOP: wedges + mix + mode -->
<div class="dockTop" id="dockTop">
  <button class="pill" data-toggle="dockTop" title="Top">🔼</button>
  <div class="mini topPanel">
    <label>Wedges<input id="wedges" type="range" min="2" max="16" step="1" value="8"></label>
    <label>Mix<input id="mix" type="range" min="0" max="1" step="0.001" value="0.5"></label>
    <div style="display:flex; gap:8px; align-items:center">
      <button id="modeK" class="pill" style="padding:6px 10px" title="Kaleidoscope">✳️</button>
      <button id="modeM" class="pill" style="padding:6px 10px" title="Mirror">🪞</button>
    </div>
  </div>
</div>

<!-- BOTTOM: decks + capture -->
<div class="dockBottom" id="dockBottom">
  <button class="pill" data-toggle="dockBottom" title="Bottom">🔽</button>
  <div class="mini botPanel">
    <label>Deck A<input id="pickA" type="file" accept="image/*,video/*"></label>
    <label>Deck B<input id="pickB" type="file" accept="image/*,video/*"></label>
    <button id="snap" class="pill" style="padding:6px 10px" title="Snapshot">📸</button>
    <button id="rec"  class="pill" style="padding:6px 10px" title="Record">⏺</button>
    <span id="recLamp" style="display:inline-block;width:10px;height:10px;margin-left:8px;border-radius:50%;background:#193b30;vertical-align:middle"></span>
  </div>
</div>

<!-- LEFT: transform -->
<div class="dockLeft" id="dockLeft">
  <button class="pill" data-toggle="dockLeft" title="Left">◀</button>
  <div class="mini leftPanel">
    <label>Zoom<input id="zoom" type="range" min="0.2" max="6" step="0.001" value="1"></label>
    <label>Rotate<input id="rot" type="range" min="-3.1416" max="3.1416" step="0.0005" value="0"></label>
    <label>Pan X<input id="panx" type="range" min="-1" max="1" step="0.0005" value="0"></label>
    <label>Pan Y<input id="pany" type="range" min="-1" max="1" step="0.0005" value="0"></label>
    <label>Spin<input id="spinHz" type="range" min="-0.05" max="0.05" step="0.0001" value="0"></label>
  </div>
</div>

<!-- RIGHT: ripple -->
<div class="dockRight" id="dockRight">
  <button class="pill" data-toggle="dockRight" title="Right">▶</button>
  <div class="mini rightPanel">
    <label>Ripple Amt<input id="rAmp" type="range" min="0" max="0.6" step="0.001" value="0.20"></label>
    <label>Frequency<input id="rFreq" type="range" min="0.5" max="12" step="0.01" value="6"></label>
    <label>Speed<input id="rSpeed" type="range" min="0" max="6" step="0.01" value="1.5"></label>
  </div>
</div>

<!-- optional tiny "Re" -->
<button class="re" onclick="location.reload()">Re</button>

<script>
/* ===== edge panel toggles ===== */
document.querySelectorAll('[data-toggle]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const id = btn.getAttribute('data-toggle');
    const dock = document.getElementById(id);
    dock.classList.toggle('open');
    document.querySelectorAll('.dockTop,.dockBottom,.dockLeft,.dockRight').forEach(d=>{
      if(d!==dock) d.classList.remove('open');
    });
  }, {passive:true});
});

/* ===== GLOBAL TOUCH LOCK FIXES ===== */
addEventListener('gesturestart', e=> e.preventDefault(), {passive:false}); // iOS pinch
addEventListener('wheel', e=> { if(e.ctrlKey) e.preventDefault(); }, {passive:false}); // ctrl+wheel zoom
function isUI(el){ return el.closest('.mini') || el.closest('.pill') || el.closest('input,button,select,textarea,label'); }
addEventListener('touchmove', e=> { if(!isUI(e.target)) e.preventDefault(); }, {passive:false});
let lastTap=0; addEventListener('touchend', e=> { const now=performance.now(); if(now-lastTap<300) e.preventDefault(); lastTap=now; }, {passive:false});
addEventListener('contextmenu', e=> e.preventDefault(), {passive:false});
addEventListener('selectstart', e=> e.preventDefault(), {passive:false});

/* ===== WebGL Kaleidoscope Engine ===== */
(function(){
  const $ = id=>document.getElementById(id);
  const cv = $('stage');

  const UI = {
    mix:$('mix'), wedges:$('wedges'),
    zoom:$('zoom'), rot:$('rot'), panx:$('panx'), pany:$('pany'), spinHz:$('spinHz'),
    rAmp:$('rAmp'), rFreq:$('rFreq'), rSpeed:$('rSpeed'),
    modeK:$('modeK'), modeM:$('modeM'),
    pickA:$('pickA'), pickB:$('pickB'),
    snap:$('snap'), rec:$('rec'), recLamp:$('recLamp')
  };

  const state = {
    mix:+UI.mix.value, wedges:+UI.wedges.value,
    zoom:+UI.zoom.value, rot:+UI.rot.value, panx:+UI.panx.value, pany:+UI.pany.value, spinHz:+UI.spinHz.value,
    rAmp:+UI.rAmp.value, rFreq:+UI.rFreq.value, rSpeed:+UI.rSpeed.value,
    mode:0
  };
  ['mix','wedges','zoom','rot','panx','pany','spinHz','rAmp','rFreq','rSpeed']
   .forEach(k=> UI[k].addEventListener('input', ()=> state[k]=+UI[k].value, {passive:true}));
  UI.modeK.onclick = ()=> state.mode=0;
  UI.modeM.onclick = ()=> state.mode=1;
function fit(){
    const dpr=Math.min(devicePixelRatio||1,2);
    const w=Math.floor(innerWidth*dpr), h=Math.floor(innerHeight*dpr);
    if(cv.width!==w||cv.height!==h){ cv.width=w; cv.height=h; }
  
  }
  addEventListener('resize', fit, {passive:true}); fit();

  const deckA = {img:null, vid:null, cvs:document.createElement('canvas'), ctx:null};
  const deckB = {img:null, vid:null, cvs:document.createElement('canvas'), ctx:null};
  deckA.ctx = deckA.cvs.getContext('2d'); deckB.ctx = deckB.cvs.getContext('2d');

  function loadTo(deck, file){
    if(!file) return;
    if(file.type.startsWith('video')){
      const v=document.createElement('video');
      v.muted=true; v.loop=true; v.playsInline=true; v.autoplay=true;
      v.onloadeddata=()=>{ v.play().catch(()=>{}); deck.vid=v; deck.img=null; };
      v.src=URL.createObjectURL(file);
    }else{
      const img=new Image();
      img.onload=()=>{ deck.img=img; deck.vid=null; };
      img.src=URL.createObjectURL(file);
    }
  }
  UI.pickA.onchange = e=>{ loadTo(deckA, e.target.files[0]); e.target.value=''; };
  UI.pickB.onchange = e=>{ loadTo(deckB, e.target.files[0]); e.target.value=''; };

  function tryGL(ver){ try{ return cv.getContext(ver,{preserveDrawingBuffer:true,antialias:true}); }catch{return null;} }
  const gl = tryGL('webgl2') || tryGL('webgl');
  if(!gl){ alert('WebGL not supported'); return; }

  const vs = `attribute vec2 aPos; varying vec2 vUv;
              void main(){ vUv=(aPos+1.0)*0.5; gl_Position=vec4(aPos,0.,1.); }`;
  const fs = `
    precision highp float; varying vec2 vUv;
    uniform sampler2D texA, texB; uniform float mixAB;
    uniform vec2 resolution; uniform float time;
    uniform int mode; uniform float wedges; uniform float zoom, rot; uniform vec2 pan;
    uniform float rAmp, rFreq, rSpeed; uniform float imgSpin;
    mat2 R(float a){ float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }
    vec2 rotAround(vec2 uv, float a){ vec2 d=uv-0.5; d=R(a)*d; return d+0.5; }
    vec2 userUV(vec2 p){
      vec2 q = R(rot)*p;
      float r = length(q);
      float wave = sin(r*rFreq - time*rSpeed);
      q *= (1.0 + wave * rAmp);
      q *= zoom; q += pan;
      return q*0.5 + 0.5;
    }
    vec3 sampleMix(vec2 uv){
      vec2 suv = rotAround(uv, imgSpin);
      vec4 a=texture2D(texA,suv), b=texture2D(texB,suv);
      return mix(a,b,clamp(mixAB,0.0,1.0)).rgb;
    }
    vec3 kaleido(){
      vec2 n=vUv*2.0-1.0; n.x *= resolution.x/resolution.y;
      float ang=atan(n.y,n.x), r=length(n);
      float sector = 6.28318530718 / max(2.0, wedges);
      float a = mod(ang, sector); if(a>0.5*sector) a = sector - a;
      vec2 dir = vec2(cos(a), sin(a));
      return sampleMix(userUV(r*dir));
    }
    vec3 mirrorFX(){
      vec2 n=vUv*2.0-1.0; n.x *= resolution.x/resolution.y;
      vec2 p = vec2(abs(n.x), n.y);
      return sampleMix(userUV(p));
    }
    void main(){ vec3 col = (mode==0)? kaleido() : mirrorFX(); gl_FragColor = vec4(col,1.0); }
  `;
  function sh(t,s){ const o=gl.createShader(t); gl.shaderSource(o,s); gl.compileShader(o); if(!gl.getShaderParameter(o,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(o); return o; }
  const pr=gl.createProgram(); gl.attachShader(pr, sh(gl.VERTEX_SHADER,vs)); gl.attachShader(pr, sh(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(pr);
  if(!gl.getProgramParameter(pr,gl.LINK_STATUS)) throw gl.getProgramInfoLog(pr);
  gl.useProgram(pr);

  const quad=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,quad);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, 1,-1, 1,1, -1,1]),gl.STATIC_DRAW);
  const aPos=gl.getAttribLocation(pr,'aPos'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

  const U={}; ['texA','texB','mixAB','resolution','time','mode','wedges','zoom','rot','pan','rAmp','rFreq','rSpeed','imgSpin'].forEach(n=>U[n]=gl.getUniformLocation(pr,n));

  function mkTex(){ const t=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.MIRRORED_REPEAT);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.MIRRORED_REPEAT);
    const c=document.createElement('canvas'); c.width=c.height=32; const x=c.getContext('2d');
    x.fillStyle='#333'; x.fillRect(0,0,32,32); x.fillStyle='#777'; x.fillRect(0,0,16,16);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,c); return t;
  }
  deckA.tex=mkTex(); deckB.tex=mkTex();

  function upload(deck){
    const src=(deck.vid && !deck.vid.paused && !deck.vid.ended)? deck.vid : deck.img; if(!src) return;
    const w=src.videoWidth||src.naturalWidth||src.width, h=src.videoHeight||src.naturalHeight||src.height; if(!w||!h) return;
    deck.cvs.width=w; deck.cvs.height=h; (deck.ctx||=deck.cvs.getContext('2d')).drawImage(src,0,0,w,h);
    gl.bindTexture(gl.TEXTURE_2D, deck.tex); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,deck.cvs);
  }

  // gestures on canvas
  const clamp=(v,lo,hi)=>Math.min(hi,Math.max(lo,v));
  const pts=new Map(); let base={panx:0,pany:0,zoom:1,rot:0,cX:0,cY:0,dist:0,ang:0};
  function centroid(){ let sx=0,sy=0; for(const p of pts.values()){sx+=p.x; sy+=p.y} const n=pts.size; return {x:sx/n,y:sy/n,n}; }
  function distAng(){ const it=pts.values(); const a=it.next().value, b=it.next().value; const dx=b.x-a.x, dy=b.y-a.y; return {dist:Math.hypot(dx,dy), ang:Math.atan2(dy,dx)}; }
  function snapshotBase(){ base={panx:state.panx,pany:state.pany,zoom:state.zoom,rot:state.rot,cX:0,cY:0,dist:0,ang:0}; if(pts.size>=2){ const c=centroid(); base.cX=c.x;base.cY=c.y; const da=distAng(); base.dist=da.dist;base.ang=da.ang; } }
  function syncUI(){ UI.panx.value=state.panx; UI.pany.value=state.pany; UI.zoom.value=state.zoom; UI.rot.value=state.rot; }

  cv.addEventListener('pointerdown', e=>{ cv.setPointerCapture(e.pointerId); pts.set(e.pointerId,{x:e.clientX,y:e.clientY}); snapshotBase(); }, {passive:false});
  cv.addEventListener('pointermove', e=>{
    if(!pts.has(e.pointerId)) return;
    pts.set(e.pointerId,{x:e.clientX,y:e.clientY});
    const c=centroid();
    if(c.n===1){
      state.panx = clamp(state.panx + (e.movementX/innerWidth)*2, -4, 4);
      state.pany = clamp(state.pany - (e.movementY/innerHeight)*2, -4, 4);
      syncUI();
    } else {
      const {dist,ang}=distAng();
      const scale = base.dist ? (dist/base.dist) : 1;
      state.zoom = clamp(base.zoom * scale, +UI.zoom.min||0.2, +UI.zoom.max||6);
      let dAng=ang-base.ang; if(dAng>Math.PI) dAng-=2*Math.PI; if(dAng<-Math.PI) dAng+=2*Math.PI;
      state.rot = clamp(base.rot + dAng, +UI.rot.min||-Math.PI, +UI.rot.max||Math.PI);
      state.panx = clamp(base.panx + ((c.x-base.cX)/innerWidth)*2, -4, 4);
      state.pany = clamp(base.pany - ((c.y-base.cY)/innerHeight)*2, -4, 4);
      syncUI();
    }
    e.preventDefault();
  }, {passive:false});
  function up(e){ pts.delete(e.pointerId); if(pts.size>0) snapshotBase(); }
  cv.addEventListener('pointerup', up, {passive:false});
  cv.addEventListener('pointercancel', up, {passive:false});
  cv.addEventListener('pointerleave', up, {passive:false});

  // draw loop
  let t0=performance.now();
  function draw(){
    fit(); upload(deckA); upload(deckB);
    gl.useProgram(pr);
    gl.uniform1i(U.texA,0); gl.uniform1i(U.texB,1);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, deckA.tex);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, deckB.tex);
    gl.uniform2f(U.resolution, cv.width, cv.height);
    const t=(performance.now()-t0)/1000.0;
    gl.uniform1f(U.time,t);
    gl.uniform1i(U.mode,state.mode);
    gl.uniform1f(U.wedges,state.wedges);
    gl.uniform1f(U.zoom,state.zoom);
    gl.uniform1f(U.rot,state.rot);
    gl.uniform2f(U.pan,state.panx,state.pany);
    gl.uniform1f(U.rAmp,state.rAmp);
    gl.uniform1f(U.rFreq,state.rFreq);
    gl.uniform1f(U.rSpeed,state.rSpeed);
    gl.uniform1f(U.imgSpin,state.spinHz*6.28318530718*t);
    gl.uniform1f(U.mixAB,state.mix);
    gl.viewport(0,0,cv.width,cv.height);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(draw);
  }
  draw();

  /* ===== Snapshot ===== */
  UI.snap.addEventListener('click', ()=>{
    try{
      const url=cv.toDataURL('image/png'); const a=document.createElement('a');
      a.href=URL.createObjectURL((()=>{const b64=url.split(',')[1]; const bin=atob(b64); const arr=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++)arr[i]=bin.charCodeAt(i); return new Blob([arr],{type:'image/png'});})());
      a.download='kaleidoscope.png'; a.click();
    }catch(e){ alert('Snapshot blocked (CORS on external media).'); }
  });

  /* ===== Robust Record (Start/Stop toggle) ===== */
  function(){
    const btn = UI.rec;
    const lamp = UI.recLamp;
    let stream=null, rec=null, chunks=[], recording=false;

    function getStream(){ if(!stream && cv.captureStream) stream=cv.captureStream(60); return stream; }
    function pickType(){
      const types=['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm','video/mp4;codecs=h264'];
      for(const t of types){ try{ if(MediaRecorder.isTypeSupported(t)) return t; }catch{} }
      return '';
    }
    function start(){
      const s=getStream();
      if(!s) return alert('canvas.captureStream not supported.');
      if(!('MediaRecorder' in window)) return alert('MediaRecorder not supported.');

      chunks=[];
      const mt = pickType();
const opts = mt
  ? { mimeType: mt, videoBitsPerSecond: 12_000_000 } // 12 Mbps
  : {                 videoBitsPerSecond: 12_000_000 };

try { rec = new MediaRecorder(s, opts); }
catch(e){ console.error(e); return alert('Recorder could not start (codec).'); }

      rec.ondataavailable = e => { if(e.data && e.data.size) chunks.push(e.data); };
      rec.onstop = () => {
        const size = chunks.reduce((n,b)=>n+b.size,0);
        if(!size){ lamp.style.background='#193b30'; btn.textContent='⏺'; recording=false; alert('No frames captured—record ~2s before stopping.'); return; }
        const blob = new Blob(chunks,{type:rec.mimeType||'video/webm'});
        const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
        a.download = blob.type.includes('mp4') ? 'kaleidoscope.mp4' : 'kaleidoscope.webm';
        a.click(); chunks=[]; lamp.style.background='#193b30'; btn.textContent='⏺'; recording=false;
      };

      rec.start(); // single blob emitted on stop
      recording=true; btn.textContent='⏹'; lamp.style.background='#ff445f';
    }
    function stop(){ try{ if(rec && rec.state!=='inactive') rec.stop(); }catch(e){ console.error(e); } }

    btn.addEventListener('click', ()=> recording ? stop() : start());
  })();

})(); // end engine
</script>
</body>
</html>
